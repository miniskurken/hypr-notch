diff --git a/Cargo.lock b/Cargo.lock
index 778dbda..3577103 100644
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -2,6 +2,18 @@
 # It is not intended for manual editing.
 version = 4
 
+[[package]]
+name = "ahash"
+version = "0.8.12"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "5a15f179cd60c4584b8a8c596927aadc462e27f2ca70c04e0071964a73ba7a75"
+dependencies = [
+ "cfg-if",
+ "once_cell",
+ "version_check",
+ "zerocopy",
+]
+
 [[package]]
 name = "aho-corasick"
 version = "1.1.3"
@@ -162,6 +174,16 @@ version = "0.1.4"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "52051878f80a721bb68ebfbc930e07b65ba72f2da88968ea5c06fd6ca3d3a127"
 
+[[package]]
+name = "fontdue"
+version = "0.7.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0793f5137567643cf65ea42043a538804ff0fbf288649e2141442b602d81f9bc"
+dependencies = [
+ "hashbrown 0.13.2",
+ "ttf-parser",
+]
+
 [[package]]
 name = "getrandom"
 version = "0.2.16"
@@ -173,6 +195,15 @@ dependencies = [
  "wasi",
 ]
 
+[[package]]
+name = "hashbrown"
+version = "0.13.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "43a3c133739dddd0d2990f9a4bdf8eb4b21ef50e4851ca85ab661199821d510e"
+dependencies = [
+ "ahash",
+]
+
 [[package]]
 name = "hashbrown"
 version = "0.16.0"
@@ -198,6 +229,7 @@ dependencies = [
  "calloop",
  "dirs",
  "env_logger",
+ "fontdue",
  "log",
  "serde",
  "smithay-client-toolkit",
@@ -213,7 +245,7 @@ source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "4b0f83760fb341a774ed326568e19f5a863af4a952def8c39f9ab92fd95b88e5"
 dependencies = [
  "equivalent",
- "hashbrown",
+ "hashbrown 0.16.0",
 ]
 
 [[package]]
@@ -285,6 +317,12 @@ dependencies = [
  "libc",
 ]
 
+[[package]]
+name = "once_cell"
+version = "1.21.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "42f5e15c9953c5e4ccceeb2e7382a716482c34515315f7b03532b8b4e8393d2d"
+
 [[package]]
 name = "option-ext"
 version = "0.2.0"
@@ -576,12 +614,24 @@ version = "0.1.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "5d99f8c9a7727884afe522e9bd5edbfc91a3312b36a77b5fb8926e4c31a41801"
 
+[[package]]
+name = "ttf-parser"
+version = "0.15.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7b3e06c9b9d80ed6b745c7159c40b311ad2916abb34a49e9be2653b90db0d8dd"
+
 [[package]]
 name = "unicode-ident"
 version = "1.0.19"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "f63a545481291138910575129486daeaf8ac54aee4387fe7906919f7830c7d9d"
 
+[[package]]
+name = "version_check"
+version = "0.9.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0b928f33d975fc6ad9f86c8f283853ad26bdd5b10b7f1542aa2fa15e2289105a"
+
 [[package]]
 name = "wasi"
 version = "0.11.1+wasi-snapshot-preview1"
@@ -877,3 +927,23 @@ checksum = "b9cc00251562a284751c9973bace760d86c0276c471b4be569fe6b068ee97a56"
 dependencies = [
  "bytemuck",
 ]
+
+[[package]]
+name = "zerocopy"
+version = "0.8.27"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0894878a5fa3edfd6da3f88c4805f4c8558e2b996227a3d864f47fe11e38282c"
+dependencies = [
+ "zerocopy-derive",
+]
+
+[[package]]
+name = "zerocopy-derive"
+version = "0.8.27"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "88d2b8d9c68ad2b9e4340d7832716a4d21a22a1154777ad56ea55c51a9cf3831"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+]
diff --git a/src/app.rs b/src/app.rs
index 3b3a566..0f3acf3 100644
--- a/src/app.rs
+++ b/src/app.rs
@@ -21,7 +21,8 @@ use smithay_client_toolkit::{
     },
     shm::{slot::SlotPool, Shm},
 };
-use std::time::{Duration, Instant};
+use std::time::Duration;
+use std::time::Instant;
 use wayland_client::protocol::{wl_pointer, wl_shm};
 
 pub struct AppData {
@@ -56,11 +57,13 @@ impl AppData {
         config: NotchConfig,
     ) -> Self {
         // Configure the layer surface
+        info!("Configuring layer surface");
         layer_surface.set_anchor(Anchor::TOP);
         layer_surface.set_keyboard_interactivity(KeyboardInteractivity::None);
         layer_surface.set_size(config.collapsed_width, config.collapsed_height);
         layer_surface.set_exclusive_zone(-1); // Don't reserve space
         layer_surface.set_margin(0, 0, 0, 0);
+        info!("Committing layer surface configuration");
         layer_surface.wl_surface().commit();
 
         // Create and initialize the module registry
@@ -123,6 +126,7 @@ impl AppData {
             }
         }
         self.last_draw = Some(now);
+        info!("Drawing surface {}x{}", self.width, self.height);
 
         let width = self.width;
         let height = self.height;
diff --git a/src/draw.rs b/src/draw.rs
index 2459291..fed59ff 100644
--- a/src/draw.rs
+++ b/src/draw.rs
@@ -5,6 +5,13 @@
 //! including handling transparency, rounded corners,
 //! and other visual elements.
 
+use fontdue::{Font, FontSettings};
+use log::{info, warn};
+use std::fs::File;
+use std::io::Read;
+use std::path::Path;
+use std::sync::OnceLock;
+
 /// Fill a canvas with color and rounded corners if expanded
 pub fn fill_canvas_with_rounded_corners(
     canvas: &mut [u8],
@@ -60,6 +67,49 @@ pub fn fill_canvas_with_rounded_corners(
     }
 }
 
+fn get_system_font() -> &'static Font {
+    static FONT: OnceLock<Font> = OnceLock::new();
+
+    FONT.get_or_init(|| {
+        // Try to load system fonts in order of preference
+        let font_paths = [
+            // Common font paths on Arch-based systems
+            "/usr/share/fonts/TTF/DejaVuSans.ttf",
+            "/usr/share/fonts/TTF/Arial.ttf",
+            "/usr/share/fonts/noto/NotoSans-Regular.ttf",
+            "/usr/share/fonts/liberation/LiberationSans-Regular.ttf",
+            // Add more potential paths here
+        ];
+
+        for path in &font_paths {
+            if let Ok(font) = load_font_from_path(path) {
+                info!("Loaded system font from {}", path);
+                return font;
+            }
+        }
+
+        // Fallback to a simple built-in font if no system fonts found
+        warn!("No system fonts found, using embedded fallback font");
+        let fallback_data = include_bytes!("../assets/fallback.ttf");
+        Font::from_bytes(fallback_data as &[u8], FontSettings::default())
+            .expect("Failed to load fallback font")
+    })
+}
+
+fn load_font_from_path(path: &str) -> Result<Font, Box<dyn std::error::Error>> {
+    let path = Path::new(path);
+    if !path.exists() {
+        return Err(format!("Font file not found: {}", path.display()).into());
+    }
+
+    let mut file = File::open(path)?;
+    let mut buffer = Vec::new();
+    file.read_to_end(&mut buffer)?;
+
+    let font = Font::from_bytes(buffer, FontSettings::default())?;
+    Ok(font)
+}
+
 /// Canvas abstraction for module drawing
 pub struct Canvas<'a> {
     buffer: &'a mut [u8],
@@ -109,14 +159,72 @@ impl<'a> Canvas<'a> {
         }
     }
 
-    /// Draw simple text (placeholder implementation - will need a proper font renderer)
-    pub fn draw_text(&mut self, x: i32, y: i32, text: &str, color: [u8; 4]) {
-        // This is a very simple placeholder that just draws a rectangle
-        // Later, you'll want to implement proper text rendering with a font library
-        let text_width = text.len() as u32 * 8; // Assume 8px per character
-        let text_height = 16; // Assume 16px height
+    /// Draw text with given color, size and position
+    pub fn draw_text(&mut self, x: i32, y: i32, text: &str, color: [u8; 4], size: f32) {
+        let font = get_system_font();
+        let scale = size;
+
+        // Track current position
+        let mut cursor_x = x;
 
-        self.fill_rect(x, y, text_width, text_height, color);
+        for c in text.chars() {
+            // Get the rasterized glyph
+            let (metrics, bitmap) = font.rasterize(c, scale);
+
+            // Skip non-renderable characters
+            if metrics.width == 0 || metrics.height == 0 {
+                cursor_x += (metrics.advance_width + 1.0) as i32;
+                continue;
+            }
+
+            // Render the glyph
+            let glyph_x = cursor_x + metrics.xmin;
+            let glyph_y = y + metrics.ymin;
+
+            for glyph_y_offset in 0..metrics.height {
+                let canvas_y = glyph_y + glyph_y_offset as i32;
+                if canvas_y < 0 || canvas_y >= self.height as i32 {
+                    continue;
+                }
+
+                for glyph_x_offset in 0..metrics.width {
+                    let canvas_x = glyph_x + glyph_x_offset as i32;
+                    if canvas_x < 0 || canvas_x >= self.width as i32 {
+                        continue;
+                    }
+
+                    // Get alpha value from bitmap
+                    let alpha = bitmap[glyph_y_offset * metrics.width + glyph_x_offset] as u16;
+                    if alpha == 0 {
+                        continue;
+                    }
+
+                    // Calculate the index in our canvas buffer
+                    let idx = (canvas_y as u32 * self.width + canvas_x as u32) as usize * 4;
+                    if idx + 3 < self.buffer.len() {
+                        // Blend the glyph with existing color
+                        let blend_alpha = alpha as f32 / 255.0;
+
+                        for i in 0..3 {
+                            let existing = self.buffer[idx + i] as f32;
+                            let new = color[i] as f32;
+                            self.buffer[idx + i] =
+                                (existing * (1.0 - blend_alpha) + new * blend_alpha) as u8;
+                        }
+
+                        // Update alpha channel
+                        let existing_alpha = self.buffer[idx + 3] as f32 / 255.0;
+                        let new_alpha = (color[3] as f32 / 255.0) * blend_alpha;
+                        let final_alpha =
+                            (existing_alpha + new_alpha * (1.0 - existing_alpha)) * 255.0;
+                        self.buffer[idx + 3] = final_alpha.min(255.0) as u8;
+                    }
+                }
+            }
+
+            // Advance cursor position
+            cursor_x += metrics.advance_width as i32;
+        }
     }
 }
 
diff --git a/src/main.rs b/src/main.rs
index bcb174f..3a3505b 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,9 +1,5 @@
-// filepath: hypr-notch/src/main.rs
+// filepath: src/main.rs
 //! Main entry point for hypr-notch
-//!
-//! This file contains the main function that initializes the application,
-//! connects to the Wayland server, and starts the event loop.
-//! It ties together all the other modules but keeps minimal logic itself.
 
 mod app;
 mod config;
@@ -13,6 +9,8 @@ mod modules;
 mod wayland;
 
 use app::AppData;
+use calloop::timer::{TimeoutAction, Timer};
+use calloop::{EventLoop, Interest, Mode};
 use config::NotchConfig;
 use log::info;
 use smithay_client_toolkit::{
@@ -23,39 +21,36 @@ use smithay_client_toolkit::{
     shell::wlr_layer::{Layer, LayerShell},
     shm::{slot::SlotPool, Shm},
 };
+use std::cell::RefCell;
+use std::rc::Rc;
+use std::time::Duration;
 use wayland_client::{globals::registry_queue_init, Connection};
 
 fn main() -> Result<(), Box<dyn std::error::Error>> {
-    // Initialize the logger
     env_logger::init();
     info!("Starting hypr-notch");
 
-    // Load configuration
     let config = NotchConfig::load_from_file().unwrap_or_default();
     info!("Configuration loaded");
 
-    // Connect to Wayland server
     let conn = Connection::connect_to_env()?;
+    let backend = conn.backend(); // Keep backend alive for event loop
     let (globals, mut event_queue) = registry_queue_init(&conn)?;
     let qh = event_queue.handle();
 
-    // Bind to global objects
     let compositor = CompositorState::bind(&globals, &qh)?;
     let layer_shell = LayerShell::bind(&globals, &qh)?;
     let shm = Shm::bind(&globals, &qh)?;
     let seat_state = SeatState::new(&globals, &qh);
 
-    // Create buffer pool for drawing
     let pool_size = (config.expanded_width * config.expanded_height * 4) as usize;
     let pool = SlotPool::new(pool_size, &shm)?;
 
-    // Create surface and layer surface
     let surface = compositor.create_surface(&qh);
     let layer_surface =
         layer_shell.create_layer_surface(&qh, surface, Layer::Top, Some("hypr-notch"), None);
 
-    // Configure and initialize the app
-    let mut app_data = AppData::new(
+    let app_data = Rc::new(RefCell::new(AppData::new(
         RegistryState::new(&globals),
         OutputState::new(&globals, &qh),
         seat_state,
@@ -64,15 +59,57 @@ fn main() -> Result<(), Box<dyn std::error::Error>> {
         layer_surface,
         pool,
         config,
-    );
+    )));
 
-    // Event loop
-    info!("Entering main event loop");
-    loop {
-        event_queue.blocking_dispatch(&mut app_data)?;
+    info!("Performing initial round-trip");
+    event_queue.roundtrip(&mut *app_data.borrow_mut())?;
 
-        if app_data.is_configured() {
-            app_data.draw()?;
-        }
-    }
+    info!("Entering main loop");
+
+    // Create calloop event loop
+    let mut event_loop: EventLoop<()> = EventLoop::try_new().expect("Failed to create event loop");
+
+    // Add Wayland event queue as a source
+    let app_data_wl = app_data.clone();
+    let mut event_queue = event_queue; // make mutable for closure
+
+    // Get the connection fd for polling as BorrowedFd
+    let wayland_fd = backend.poll_fd();
+
+    event_loop
+        .handle()
+        .insert_source(
+            calloop::generic::Generic::new(wayland_fd, Interest::READ, Mode::Level),
+            move |_, _, _| {
+                let _ = event_queue.dispatch_pending(&mut *app_data_wl.borrow_mut());
+                let _ = event_queue.flush();
+                Ok(calloop::PostAction::Continue)
+            },
+        )
+        .expect("Failed to insert Wayland source");
+
+    // Add timer for periodic updates
+    let app_data_timer = app_data.clone();
+    let timer = Timer::from_duration(Duration::from_secs(1));
+    event_loop
+        .handle()
+        .insert_source(timer, move |_, _, _| {
+            info!("Updating modules (timer)");
+            let mut app_data = app_data_timer.borrow_mut();
+            app_data.update_modules();
+            if app_data.is_configured() {
+                info!("Redrawing surface (timer)");
+                let _ = app_data.draw();
+            }
+            TimeoutAction::ToDuration(Duration::from_secs(1))
+        })
+        .expect("Failed to insert timer");
+
+    // Run the event loop
+    event_loop
+        .run(None, &mut (), |_| {})
+        .expect("Event loop failed");
+
+    info!("Exiting hypr-notch");
+    Ok(())
 }
diff --git a/src/modules/clock.rs b/src/modules/clock.rs
index 2c220bf..e8151cc 100644
--- a/src/modules/clock.rs
+++ b/src/modules/clock.rs
@@ -12,6 +12,8 @@ pub struct ClockModule {
     name: String,
     color: [u8; 4],
     format: String,
+    font_size: f32,
+    background_color: [u8; 4],
 }
 
 impl ClockModule {
@@ -21,12 +23,13 @@ impl ClockModule {
             name: "Clock".to_string(),
             color: [255, 255, 255, 255], // White
             format: "%H:%M:%S".to_string(),
+            font_size: 16.0,
+            background_color: [50, 50, 50, 200], // Semi-transparent dark gray
         }
     }
 
     fn get_current_time(&self) -> String {
         // Simple implementation that shows HH:MM:SS
-        // Later you can use chrono for better formatting
         let now = SystemTime::now()
             .duration_since(UNIX_EPOCH)
             .unwrap_or_default()
@@ -66,16 +69,28 @@ impl Module for ClockModule {
             self.format = format.to_string();
         }
 
+        // Parse font size if present
+        if let Some(size) = config.get("font_size").and_then(|v| v.as_float()) {
+            self.font_size = size as f32;
+        }
+
         Ok(())
     }
 
     fn draw(&self, canvas: &mut Canvas, area: Rect) -> Result<(), Box<dyn std::error::Error>> {
-        // Fill background for debugging
-        canvas.fill_rect(area.x, area.y, area.width, area.height, [50, 50, 50, 200]);
+        // Fill background
+        canvas.fill_rect(
+            area.x,
+            area.y,
+            area.width,
+            area.height,
+            self.background_color,
+        );
 
         // Draw time text
         let time_str = self.get_current_time();
-        canvas.draw_text(area.x + 5, area.y + 5, &time_str, self.color);
+        let y_pos = area.y + ((area.height as i32 - self.font_size as i32) / 2);
+        canvas.draw_text(area.x + 10, y_pos, &time_str, self.color, self.font_size);
 
         Ok(())
     }
diff --git a/src/wayland.rs b/src/wayland.rs
index 5a0659a..ea7d918 100644
--- a/src/wayland.rs
+++ b/src/wayland.rs
@@ -1,13 +1,9 @@
-// filepath: hypr-notch/src/wayland.rs
+// filepath: src/wayland.rs
 //! Wayland protocol handlers for hypr-notch
-//!
-//! This file implements the various Wayland protocol handlers
-//! required by the application, including compositor, output,
-//! layer shell, seat, and pointer handlers.
 
 use crate::app::AppData;
 use crate::module::interface::convert_pointer_event;
-use log::{debug, info};
+use log::{debug, info, warn};
 use smithay_client_toolkit::{
     compositor::CompositorHandler,
     delegate_compositor, delegate_layer, delegate_output, delegate_pointer, delegate_registry,
@@ -35,7 +31,6 @@ impl CompositorHandler for AppData {
         _surface: &wl_surface::WlSurface,
         _new_factor: i32,
     ) {
-        // Handle scale factor changes if needed
     }
 
     fn transform_changed(
@@ -45,7 +40,6 @@ impl CompositorHandler for AppData {
         _surface: &wl_surface::WlSurface,
         _new_transform: wl_output::Transform,
     ) {
-        // Handle transform changes if needed
     }
 
     fn frame(
@@ -55,7 +49,6 @@ impl CompositorHandler for AppData {
         _surface: &wl_surface::WlSurface,
         _time: u32,
     ) {
-        // Send update event to modules on frame events
         if self.expanded {
             self.update_modules();
         }
@@ -73,7 +66,6 @@ impl OutputHandler for AppData {
         _qh: &QueueHandle<Self>,
         _output: wl_output::WlOutput,
     ) {
-        // Handle new outputs
     }
 
     fn update_output(
@@ -82,7 +74,6 @@ impl OutputHandler for AppData {
         _qh: &QueueHandle<Self>,
         _output: wl_output::WlOutput,
     ) {
-        // Handle output updates
     }
 
     fn output_destroyed(
@@ -91,7 +82,6 @@ impl OutputHandler for AppData {
         _qh: &QueueHandle<Self>,
         _output: wl_output::WlOutput,
     ) {
-        // Handle output destruction
     }
 }
 
@@ -108,7 +98,7 @@ impl LayerShellHandler for AppData {
         configure: LayerSurfaceConfigure,
         _serial: u32,
     ) {
-        // Only update dimensions if server provides non-zero values
+        info!("Surface configured to size: {:?}", configure.new_size);
         let mut width = self.width;
         let mut height = self.height;
 
@@ -121,6 +111,8 @@ impl LayerShellHandler for AppData {
 
         self.update_size(width, height);
         self.set_configured(true);
+
+        info!("Surface now configured with size: {}x{}", width, height);
     }
 }
 
@@ -129,9 +121,7 @@ impl SeatHandler for AppData {
         self.seat_state()
     }
 
-    fn new_seat(&mut self, _conn: &Connection, _qh: &QueueHandle<Self>, _seat: wl_seat::WlSeat) {
-        // Handle new seat
-    }
+    fn new_seat(&mut self, _conn: &Connection, _qh: &QueueHandle<Self>, _seat: wl_seat::WlSeat) {}
 
     fn new_capability(
         &mut self,
@@ -140,9 +130,13 @@ impl SeatHandler for AppData {
         seat: wl_seat::WlSeat,
         capability: Capability,
     ) {
-        // Get pointer capability when available
         if capability == Capability::Pointer {
             let pointer = self.seat_state().get_pointer(qh, &seat).ok();
+            if pointer.is_some() {
+                info!("Pointer capability acquired and pointer created");
+            } else {
+                warn!("Pointer capability acquired but pointer creation failed");
+            }
             self.set_pointer(pointer);
         }
     }
@@ -154,14 +148,12 @@ impl SeatHandler for AppData {
         _seat: wl_seat::WlSeat,
         capability: Capability,
     ) {
-        // Release pointer when capability is removed
         if capability == Capability::Pointer {
             self.set_pointer(None);
         }
     }
 
     fn remove_seat(&mut self, _conn: &Connection, _qh: &QueueHandle<Self>, _seat: wl_seat::WlSeat) {
-        // Handle seat removal
     }
 }
 
@@ -174,17 +166,19 @@ impl PointerHandler for AppData {
         events: &[PointerEvent],
     ) {
         for event in events {
-            // Log pointer events
+            info!("Pointer event: {:?}", event.kind);
             match event.kind {
                 PointerEventKind::Enter { .. } => {
                     info!(
                         "Mouse entered notch area at coordinates: ({:.2}, {:.2})",
                         event.position.0, event.position.1
                     );
+                    info!("Expanding notch due to mouse enter");
                     self.resize(true);
                 }
                 PointerEventKind::Leave { .. } => {
                     info!("Mouse left notch area");
+                    info!("Collapsing notch due to mouse leave");
                     self.resize(false);
                 }
                 PointerEventKind::Motion { .. } => {
@@ -193,19 +187,12 @@ impl PointerHandler for AppData {
                         event.position.0, event.position.1
                     );
                 }
-                PointerEventKind::Press { .. } => {
-                    debug!("Mouse button pressed in notch area");
-                }
-                PointerEventKind::Release { .. } => {
-                    debug!("Mouse button released in notch area");
-                }
                 _ => {}
             }
 
-            // Forward events to modules when expanded
             if self.expanded {
-                if let Some(module_event) = convert_pointer_event(event) {
-                    self.update_modules(); // Update modules on any pointer event
+                if let Some(_module_event) = convert_pointer_event(event) {
+                    self.update_modules();
                 }
             }
         }
